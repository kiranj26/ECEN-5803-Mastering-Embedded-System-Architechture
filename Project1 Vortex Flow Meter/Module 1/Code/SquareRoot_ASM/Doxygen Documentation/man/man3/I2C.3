.TH "I2C" 3 "Version 0.1.-" "Square Root Approximation" \" -*- nroff -*-
.ad l
.nh
.SH NAME
I2C \- I2C
.PP
 \- I2C driver modules\&.  

.SH SYNOPSIS
.br
.PP
.SS "Modules"

.in +1c
.ti -1c
.RI "\fBI2C_Private_Functions\fP"
.br
.ti -1c
.RI "\fBI2C_Exported_Constants\fP"
.br
.in -1c
.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBI2C_InitTypeDef\fP"
.br
.RI "I2C Init structure definition 
.br
 "
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBCR1_CLEAR_MASK\fP   ((uint16_t)0xFBF5)      /*<! I2C registers Masks */"
.br
.ti -1c
.RI "#define \fBFLAG_MASK\fP   ((uint32_t)0x00FFFFFF)  /*<! I2C FLAG mask */"
.br
.ti -1c
.RI "#define \fBITEN_MASK\fP   ((uint32_t)0x07000000)  /*<! I2C Interrupt Enable mask */"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBI2C_DeInit\fP (I2C_TypeDef *I2Cx)"
.br
.RI "Deinitialize the I2Cx peripheral registers to their default reset values\&. "
.ti -1c
.RI "void \fBI2C_Init\fP (I2C_TypeDef *I2Cx, \fBI2C_InitTypeDef\fP *I2C_InitStruct)"
.br
.RI "Initializes the I2Cx peripheral according to the specified parameters in the I2C_InitStruct\&. "
.ti -1c
.RI "void \fBI2C_StructInit\fP (\fBI2C_InitTypeDef\fP *I2C_InitStruct)"
.br
.RI "Fills each I2C_InitStruct member with its default value\&. "
.ti -1c
.RI "void \fBI2C_Cmd\fP (I2C_TypeDef *I2Cx, FunctionalState NewState)"
.br
.RI "Enables or disables the specified I2C peripheral\&. "
.ti -1c
.RI "void \fBI2C_GenerateSTART\fP (I2C_TypeDef *I2Cx, FunctionalState NewState)"
.br
.RI "Generates I2Cx communication START condition\&. "
.ti -1c
.RI "void \fBI2C_GenerateSTOP\fP (I2C_TypeDef *I2Cx, FunctionalState NewState)"
.br
.RI "Generates I2Cx communication STOP condition\&. "
.ti -1c
.RI "void \fBI2C_Send7bitAddress\fP (I2C_TypeDef *I2Cx, uint8_t Address, uint8_t I2C_Direction)"
.br
.RI "Transmits the address byte to select the slave device\&. "
.ti -1c
.RI "void \fBI2C_AcknowledgeConfig\fP (I2C_TypeDef *I2Cx, FunctionalState NewState)"
.br
.RI "Enables or disables the specified I2C acknowledge feature\&. "
.ti -1c
.RI "void \fBI2C_OwnAddress2Config\fP (I2C_TypeDef *I2Cx, uint8_t Address)"
.br
.RI "Configures the specified I2C own address2\&. "
.ti -1c
.RI "void \fBI2C_DualAddressCmd\fP (I2C_TypeDef *I2Cx, FunctionalState NewState)"
.br
.RI "Enables or disables the specified I2C dual addressing mode\&. "
.ti -1c
.RI "void \fBI2C_GeneralCallCmd\fP (I2C_TypeDef *I2Cx, FunctionalState NewState)"
.br
.RI "Enables or disables the specified I2C general call feature\&. "
.ti -1c
.RI "void \fBI2C_SoftwareResetCmd\fP (I2C_TypeDef *I2Cx, FunctionalState NewState)"
.br
.RI "Enables or disables the specified I2C software reset\&. "
.ti -1c
.RI "void \fBI2C_StretchClockCmd\fP (I2C_TypeDef *I2Cx, FunctionalState NewState)"
.br
.RI "Enables or disables the specified I2C Clock stretching\&. "
.ti -1c
.RI "void \fBI2C_FastModeDutyCycleConfig\fP (I2C_TypeDef *I2Cx, uint16_t I2C_DutyCycle)"
.br
.RI "Selects the specified I2C fast mode duty cycle\&. "
.ti -1c
.RI "void \fBI2C_NACKPositionConfig\fP (I2C_TypeDef *I2Cx, uint16_t I2C_NACKPosition)"
.br
.RI "Selects the specified I2C NACK position in master receiver mode\&. "
.ti -1c
.RI "void \fBI2C_SMBusAlertConfig\fP (I2C_TypeDef *I2Cx, uint16_t I2C_SMBusAlert)"
.br
.RI "Drives the SMBusAlert pin high or low for the specified I2C\&. "
.ti -1c
.RI "void \fBI2C_ARPCmd\fP (I2C_TypeDef *I2Cx, FunctionalState NewState)"
.br
.RI "Enables or disables the specified I2C ARP\&. "
.ti -1c
.RI "void \fBI2C_SendData\fP (I2C_TypeDef *I2Cx, uint8_t Data)"
.br
.RI "Sends a data byte through the I2Cx peripheral\&. "
.ti -1c
.RI "uint8_t \fBI2C_ReceiveData\fP (I2C_TypeDef *I2Cx)"
.br
.RI "Returns the most recent received data by the I2Cx peripheral\&. "
.ti -1c
.RI "void \fBI2C_TransmitPEC\fP (I2C_TypeDef *I2Cx, FunctionalState NewState)"
.br
.RI "Enables or disables the specified I2C PEC transfer\&. "
.ti -1c
.RI "void \fBI2C_PECPositionConfig\fP (I2C_TypeDef *I2Cx, uint16_t I2C_PECPosition)"
.br
.RI "Selects the specified I2C PEC position\&. "
.ti -1c
.RI "void \fBI2C_CalculatePEC\fP (I2C_TypeDef *I2Cx, FunctionalState NewState)"
.br
.RI "Enables or disables the PEC value calculation of the transferred bytes\&. "
.ti -1c
.RI "uint8_t \fBI2C_GetPEC\fP (I2C_TypeDef *I2Cx)"
.br
.RI "Returns the PEC value for the specified I2C\&. "
.ti -1c
.RI "void \fBI2C_DMACmd\fP (I2C_TypeDef *I2Cx, FunctionalState NewState)"
.br
.RI "Enables or disables the specified I2C DMA requests\&. "
.ti -1c
.RI "void \fBI2C_DMALastTransferCmd\fP (I2C_TypeDef *I2Cx, FunctionalState NewState)"
.br
.RI "Specifies that the next DMA transfer is the last one\&. "
.ti -1c
.RI "uint16_t \fBI2C_ReadRegister\fP (I2C_TypeDef *I2Cx, uint8_t I2C_Register)"
.br
.RI "Reads the specified I2C register and returns its value\&. "
.ti -1c
.RI "void \fBI2C_ITConfig\fP (I2C_TypeDef *I2Cx, uint16_t I2C_IT, FunctionalState NewState)"
.br
.RI "Enables or disables the specified I2C interrupts\&. "
.ti -1c
.RI "ErrorStatus \fBI2C_CheckEvent\fP (I2C_TypeDef *I2Cx, uint32_t I2C_EVENT)"
.br
.RI "Checks whether the last I2Cx Event is equal to the one passed as parameter\&. "
.ti -1c
.RI "uint32_t \fBI2C_GetLastEvent\fP (I2C_TypeDef *I2Cx)"
.br
.RI "Returns the last I2Cx Event\&. "
.ti -1c
.RI "FlagStatus \fBI2C_GetFlagStatus\fP (I2C_TypeDef *I2Cx, uint32_t I2C_FLAG)"
.br
.RI "Checks whether the specified I2C flag is set or not\&. "
.ti -1c
.RI "void \fBI2C_ClearFlag\fP (I2C_TypeDef *I2Cx, uint32_t I2C_FLAG)"
.br
.RI "Clears the I2Cx's pending flags\&. "
.ti -1c
.RI "ITStatus \fBI2C_GetITStatus\fP (I2C_TypeDef *I2Cx, uint32_t I2C_IT)"
.br
.RI "Checks whether the specified I2C interrupt has occurred or not\&. "
.ti -1c
.RI "void \fBI2C_ClearITPendingBit\fP (I2C_TypeDef *I2Cx, uint32_t I2C_IT)"
.br
.RI "Clears the I2Cx's interrupt pending bits\&. "
.in -1c
.SH "Detailed Description"
.PP 
I2C driver modules\&. 


.SH "Macro Definition Documentation"
.PP 
.SS "#define CR1_CLEAR_MASK   ((uint16_t)0xFBF5)      /*<! I2C registers Masks */"

.SS "#define FLAG_MASK   ((uint32_t)0x00FFFFFF)  /*<! I2C FLAG mask */"

.SS "#define ITEN_MASK   ((uint32_t)0x07000000)  /*<! I2C Interrupt Enable mask */"

.SH "Function Documentation"
.PP 
.SS "void I2C_AcknowledgeConfig (I2C_TypeDef * I2Cx, FunctionalState NewState)"

.PP
Enables or disables the specified I2C acknowledge feature\&. 
.PP
\fBParameters\fP
.RS 4
\fII2Cx\fP where x can be 1, 2 or 3 to select the I2C peripheral\&. 
.br
\fINewState\fP new state of the I2C Acknowledgement\&. This parameter can be: ENABLE or DISABLE\&. 
.RE
.PP
\fBReturn values\fP
.RS 4
\fINone\&.\fP 
.RE
.PP

.SS "void I2C_ARPCmd (I2C_TypeDef * I2Cx, FunctionalState NewState)"

.PP
Enables or disables the specified I2C ARP\&. 
.PP
\fBParameters\fP
.RS 4
\fII2Cx\fP where x can be 1, 2 or 3 to select the I2C peripheral\&. 
.br
\fINewState\fP new state of the I2Cx ARP\&. This parameter can be: ENABLE or DISABLE\&. 
.RE
.PP
\fBReturn values\fP
.RS 4
\fINone\fP 
.RE
.PP

.SS "void I2C_CalculatePEC (I2C_TypeDef * I2Cx, FunctionalState NewState)"

.PP
Enables or disables the PEC value calculation of the transferred bytes\&. 
.PP
\fBParameters\fP
.RS 4
\fII2Cx\fP where x can be 1, 2 or 3 to select the I2C peripheral\&. 
.br
\fINewState\fP new state of the I2Cx PEC value calculation\&. This parameter can be: ENABLE or DISABLE\&. 
.RE
.PP
\fBReturn values\fP
.RS 4
\fINone\fP 
.RE
.PP

.SS "ErrorStatus I2C_CheckEvent (I2C_TypeDef * I2Cx, uint32_t I2C_EVENT)"

.PP
Checks whether the last I2Cx Event is equal to the one passed as parameter\&. 
.PP
\fBParameters\fP
.RS 4
\fII2Cx\fP where x can be 1, 2 or 3 to select the I2C peripheral\&. 
.br
\fII2C_EVENT\fP specifies the event to be checked\&. This parameter can be one of the following values: 
.PD 0
.IP "\(bu" 1
I2C_EVENT_SLAVE_TRANSMITTER_ADDRESS_MATCHED: EV1 
.IP "\(bu" 1
I2C_EVENT_SLAVE_RECEIVER_ADDRESS_MATCHED: EV1 
.IP "\(bu" 1
I2C_EVENT_SLAVE_TRANSMITTER_SECONDADDRESS_MATCHED: EV1 
.IP "\(bu" 1
I2C_EVENT_SLAVE_RECEIVER_SECONDADDRESS_MATCHED: EV1 
.IP "\(bu" 1
I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED: EV1 
.IP "\(bu" 1
I2C_EVENT_SLAVE_BYTE_RECEIVED: EV2 
.IP "\(bu" 1
(I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_DUALF): EV2 
.IP "\(bu" 1
(I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_GENCALL): EV2 
.IP "\(bu" 1
I2C_EVENT_SLAVE_BYTE_TRANSMITTED: EV3 
.IP "\(bu" 1
(I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_DUALF): EV3 
.IP "\(bu" 1
(I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_GENCALL): EV3 
.IP "\(bu" 1
I2C_EVENT_SLAVE_ACK_FAILURE: EV3_2 
.IP "\(bu" 1
I2C_EVENT_SLAVE_STOP_DETECTED: EV4 
.IP "\(bu" 1
I2C_EVENT_MASTER_MODE_SELECT: EV5 
.IP "\(bu" 1
I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED: EV6 
.br
 
.IP "\(bu" 1
I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED: EV6 
.IP "\(bu" 1
I2C_EVENT_MASTER_BYTE_RECEIVED: EV7 
.IP "\(bu" 1
I2C_EVENT_MASTER_BYTE_TRANSMITTING: EV8 
.IP "\(bu" 1
I2C_EVENT_MASTER_BYTE_TRANSMITTED: EV8_2 
.IP "\(bu" 1
I2C_EVENT_MASTER_MODE_ADDRESS10: EV9
.PP
.RE
.PP
\fBNote\fP
.RS 4
For detailed description of Events, please refer to section I2C_Events in \fBstm32f4xx_i2c\&.h\fP file\&.
.RE
.PP
\fBReturn values\fP
.RS 4
\fIAn\fP ErrorStatus enumeration value:
.IP "\(bu" 2
SUCCESS: Last event is equal to the I2C_EVENT
.IP "\(bu" 2
ERROR: Last event is different from the I2C_EVENT 
.PP
.RE
.PP

.SS "void I2C_ClearFlag (I2C_TypeDef * I2Cx, uint32_t I2C_FLAG)"

.PP
Clears the I2Cx's pending flags\&. 
.PP
\fBParameters\fP
.RS 4
\fII2Cx\fP where x can be 1, 2 or 3 to select the I2C peripheral\&. 
.br
\fII2C_FLAG\fP specifies the flag to clear\&. This parameter can be any combination of the following values: 
.PD 0
.IP "\(bu" 1
I2C_FLAG_SMBALERT: SMBus Alert flag 
.IP "\(bu" 1
I2C_FLAG_TIMEOUT: Timeout or Tlow error flag 
.IP "\(bu" 1
I2C_FLAG_PECERR: PEC error in reception flag 
.IP "\(bu" 1
I2C_FLAG_OVR: Overrun/Underrun flag (Slave mode) 
.IP "\(bu" 1
I2C_FLAG_AF: Acknowledge failure flag 
.IP "\(bu" 1
I2C_FLAG_ARLO: Arbitration lost flag (Master mode) 
.IP "\(bu" 1
I2C_FLAG_BERR: Bus error flag
.PP
.RE
.PP
\fBNote\fP
.RS 4
STOPF (STOP detection) is cleared by software sequence: a read operation to I2C_SR1 register (\fBI2C_GetFlagStatus()\fP) followed by a write operation to I2C_CR1 register (\fBI2C_Cmd()\fP to re-enable the I2C peripheral)\&. 
.PP
ADD10 (10-bit header sent) is cleared by software sequence: a read operation to I2C_SR1 (\fBI2C_GetFlagStatus()\fP) followed by writing the second byte of the address in DR register\&. 
.PP
BTF (Byte Transfer Finished) is cleared by software sequence: a read operation to I2C_SR1 register (\fBI2C_GetFlagStatus()\fP) followed by a read/write to I2C_DR register (\fBI2C_SendData()\fP)\&. 
.PP
ADDR (Address sent) is cleared by software sequence: a read operation to I2C_SR1 register (\fBI2C_GetFlagStatus()\fP) followed by a read operation to I2C_SR2 register ((void)(I2Cx->SR2))\&. 
.PP
SB (Start Bit) is cleared software sequence: a read operation to I2C_SR1 register (\fBI2C_GetFlagStatus()\fP) followed by a write operation to I2C_DR register (\fBI2C_SendData()\fP)\&.
.RE
.PP
\fBReturn values\fP
.RS 4
\fINone\fP 
.RE
.PP

.SS "void I2C_ClearITPendingBit (I2C_TypeDef * I2Cx, uint32_t I2C_IT)"

.PP
Clears the I2Cx's interrupt pending bits\&. 
.PP
\fBParameters\fP
.RS 4
\fII2Cx\fP where x can be 1, 2 or 3 to select the I2C peripheral\&. 
.br
\fII2C_IT\fP specifies the interrupt pending bit to clear\&. This parameter can be any combination of the following values: 
.PD 0
.IP "\(bu" 1
I2C_IT_SMBALERT: SMBus Alert interrupt 
.IP "\(bu" 1
I2C_IT_TIMEOUT: Timeout or Tlow error interrupt 
.IP "\(bu" 1
I2C_IT_PECERR: PEC error in reception interrupt 
.IP "\(bu" 1
I2C_IT_OVR: Overrun/Underrun interrupt (Slave mode) 
.IP "\(bu" 1
I2C_IT_AF: Acknowledge failure interrupt 
.IP "\(bu" 1
I2C_IT_ARLO: Arbitration lost interrupt (Master mode) 
.IP "\(bu" 1
I2C_IT_BERR: Bus error interrupt
.PP
.RE
.PP
\fBNote\fP
.RS 4
STOPF (STOP detection) is cleared by software sequence: a read operation to I2C_SR1 register (\fBI2C_GetITStatus()\fP) followed by a write operation to I2C_CR1 register (\fBI2C_Cmd()\fP to re-enable the I2C peripheral)\&. 
.PP
ADD10 (10-bit header sent) is cleared by software sequence: a read operation to I2C_SR1 (\fBI2C_GetITStatus()\fP) followed by writing the second byte of the address in I2C_DR register\&. 
.PP
BTF (Byte Transfer Finished) is cleared by software sequence: a read operation to I2C_SR1 register (\fBI2C_GetITStatus()\fP) followed by a read/write to I2C_DR register (\fBI2C_SendData()\fP)\&. 
.PP
ADDR (Address sent) is cleared by software sequence: a read operation to I2C_SR1 register (\fBI2C_GetITStatus()\fP) followed by a read operation to I2C_SR2 register ((void)(I2Cx->SR2))\&. 
.PP
SB (Start Bit) is cleared by software sequence: a read operation to I2C_SR1 register (\fBI2C_GetITStatus()\fP) followed by a write operation to I2C_DR register (\fBI2C_SendData()\fP)\&. 
.RE
.PP
\fBReturn values\fP
.RS 4
\fINone\fP 
.RE
.PP

.SS "void I2C_Cmd (I2C_TypeDef * I2Cx, FunctionalState NewState)"

.PP
Enables or disables the specified I2C peripheral\&. 
.PP
\fBParameters\fP
.RS 4
\fII2Cx\fP where x can be 1, 2 or 3 to select the I2C peripheral\&. 
.br
\fINewState\fP new state of the I2Cx peripheral\&. This parameter can be: ENABLE or DISABLE\&. 
.RE
.PP
\fBReturn values\fP
.RS 4
\fINone\fP 
.RE
.PP

.SS "void I2C_DeInit (I2C_TypeDef * I2Cx)"

.PP
Deinitialize the I2Cx peripheral registers to their default reset values\&. 
.PP
\fBParameters\fP
.RS 4
\fII2Cx\fP where x can be 1, 2 or 3 to select the I2C peripheral\&. 
.RE
.PP
\fBReturn values\fP
.RS 4
\fINone\fP 
.RE
.PP

.SS "void I2C_DMACmd (I2C_TypeDef * I2Cx, FunctionalState NewState)"

.PP
Enables or disables the specified I2C DMA requests\&. 
.PP
\fBParameters\fP
.RS 4
\fII2Cx\fP where x can be 1, 2 or 3 to select the I2C peripheral\&. 
.br
\fINewState\fP new state of the I2C DMA transfer\&. This parameter can be: ENABLE or DISABLE\&. 
.RE
.PP
\fBReturn values\fP
.RS 4
\fINone\fP 
.RE
.PP

.SS "void I2C_DMALastTransferCmd (I2C_TypeDef * I2Cx, FunctionalState NewState)"

.PP
Specifies that the next DMA transfer is the last one\&. 
.PP
\fBParameters\fP
.RS 4
\fII2Cx\fP where x can be 1, 2 or 3 to select the I2C peripheral\&. 
.br
\fINewState\fP new state of the I2C DMA last transfer\&. This parameter can be: ENABLE or DISABLE\&. 
.RE
.PP
\fBReturn values\fP
.RS 4
\fINone\fP 
.RE
.PP

.SS "void I2C_DualAddressCmd (I2C_TypeDef * I2Cx, FunctionalState NewState)"

.PP
Enables or disables the specified I2C dual addressing mode\&. 
.PP
\fBParameters\fP
.RS 4
\fII2Cx\fP where x can be 1, 2 or 3 to select the I2C peripheral\&. 
.br
\fINewState\fP new state of the I2C dual addressing mode\&. This parameter can be: ENABLE or DISABLE\&. 
.RE
.PP
\fBReturn values\fP
.RS 4
\fINone\fP 
.RE
.PP

.SS "void I2C_FastModeDutyCycleConfig (I2C_TypeDef * I2Cx, uint16_t I2C_DutyCycle)"

.PP
Selects the specified I2C fast mode duty cycle\&. 
.PP
\fBParameters\fP
.RS 4
\fII2Cx\fP where x can be 1, 2 or 3 to select the I2C peripheral\&. 
.br
\fII2C_DutyCycle\fP specifies the fast mode duty cycle\&. This parameter can be one of the following values: 
.PD 0
.IP "\(bu" 1
I2C_DutyCycle_2: I2C fast mode Tlow/Thigh = 2 
.IP "\(bu" 1
I2C_DutyCycle_16_9: I2C fast mode Tlow/Thigh = 16/9 
.PP
.RE
.PP
\fBReturn values\fP
.RS 4
\fINone\fP 
.RE
.PP

.SS "void I2C_GeneralCallCmd (I2C_TypeDef * I2Cx, FunctionalState NewState)"

.PP
Enables or disables the specified I2C general call feature\&. 
.PP
\fBParameters\fP
.RS 4
\fII2Cx\fP where x can be 1, 2 or 3 to select the I2C peripheral\&. 
.br
\fINewState\fP new state of the I2C General call\&. This parameter can be: ENABLE or DISABLE\&. 
.RE
.PP
\fBReturn values\fP
.RS 4
\fINone\fP 
.RE
.PP

.SS "void I2C_GenerateSTART (I2C_TypeDef * I2Cx, FunctionalState NewState)"

.PP
Generates I2Cx communication START condition\&. 
.PP
\fBParameters\fP
.RS 4
\fII2Cx\fP where x can be 1, 2 or 3 to select the I2C peripheral\&. 
.br
\fINewState\fP new state of the I2C START condition generation\&. This parameter can be: ENABLE or DISABLE\&. 
.RE
.PP
\fBReturn values\fP
.RS 4
\fINone\&.\fP 
.RE
.PP

.SS "void I2C_GenerateSTOP (I2C_TypeDef * I2Cx, FunctionalState NewState)"

.PP
Generates I2Cx communication STOP condition\&. 
.PP
\fBParameters\fP
.RS 4
\fII2Cx\fP where x can be 1, 2 or 3 to select the I2C peripheral\&. 
.br
\fINewState\fP new state of the I2C STOP condition generation\&. This parameter can be: ENABLE or DISABLE\&. 
.RE
.PP
\fBReturn values\fP
.RS 4
\fINone\&.\fP 
.RE
.PP

.SS "FlagStatus I2C_GetFlagStatus (I2C_TypeDef * I2Cx, uint32_t I2C_FLAG)"

.PP
Checks whether the specified I2C flag is set or not\&. 
.PP
\fBParameters\fP
.RS 4
\fII2Cx\fP where x can be 1, 2 or 3 to select the I2C peripheral\&. 
.br
\fII2C_FLAG\fP specifies the flag to check\&. This parameter can be one of the following values: 
.PD 0
.IP "\(bu" 1
I2C_FLAG_DUALF: Dual flag (Slave mode) 
.IP "\(bu" 1
I2C_FLAG_SMBHOST: SMBus host header (Slave mode) 
.IP "\(bu" 1
I2C_FLAG_SMBDEFAULT: SMBus default header (Slave mode) 
.IP "\(bu" 1
I2C_FLAG_GENCALL: General call header flag (Slave mode) 
.IP "\(bu" 1
I2C_FLAG_TRA: Transmitter/Receiver flag 
.IP "\(bu" 1
I2C_FLAG_BUSY: Bus busy flag 
.IP "\(bu" 1
I2C_FLAG_MSL: Master/Slave flag 
.IP "\(bu" 1
I2C_FLAG_SMBALERT: SMBus Alert flag 
.IP "\(bu" 1
I2C_FLAG_TIMEOUT: Timeout or Tlow error flag 
.IP "\(bu" 1
I2C_FLAG_PECERR: PEC error in reception flag 
.IP "\(bu" 1
I2C_FLAG_OVR: Overrun/Underrun flag (Slave mode) 
.IP "\(bu" 1
I2C_FLAG_AF: Acknowledge failure flag 
.IP "\(bu" 1
I2C_FLAG_ARLO: Arbitration lost flag (Master mode) 
.IP "\(bu" 1
I2C_FLAG_BERR: Bus error flag 
.IP "\(bu" 1
I2C_FLAG_TXE: Data register empty flag (Transmitter) 
.IP "\(bu" 1
I2C_FLAG_RXNE: Data register not empty (Receiver) flag 
.IP "\(bu" 1
I2C_FLAG_STOPF: Stop detection flag (Slave mode) 
.IP "\(bu" 1
I2C_FLAG_ADD10: 10-bit header sent flag (Master mode) 
.IP "\(bu" 1
I2C_FLAG_BTF: Byte transfer finished flag 
.IP "\(bu" 1
I2C_FLAG_ADDR: Address sent flag (Master mode) 'ADSL' Address matched flag (Slave mode)'ENDAD' 
.IP "\(bu" 1
I2C_FLAG_SB: Start bit flag (Master mode) 
.PP
.RE
.PP
\fBReturn values\fP
.RS 4
\fIThe\fP new state of I2C_FLAG (SET or RESET)\&. 
.RE
.PP

.SS "ITStatus I2C_GetITStatus (I2C_TypeDef * I2Cx, uint32_t I2C_IT)"

.PP
Checks whether the specified I2C interrupt has occurred or not\&. 
.PP
\fBParameters\fP
.RS 4
\fII2Cx\fP where x can be 1, 2 or 3 to select the I2C peripheral\&. 
.br
\fII2C_IT\fP specifies the interrupt source to check\&. This parameter can be one of the following values: 
.PD 0
.IP "\(bu" 1
I2C_IT_SMBALERT: SMBus Alert flag 
.IP "\(bu" 1
I2C_IT_TIMEOUT: Timeout or Tlow error flag 
.IP "\(bu" 1
I2C_IT_PECERR: PEC error in reception flag 
.IP "\(bu" 1
I2C_IT_OVR: Overrun/Underrun flag (Slave mode) 
.IP "\(bu" 1
I2C_IT_AF: Acknowledge failure flag 
.IP "\(bu" 1
I2C_IT_ARLO: Arbitration lost flag (Master mode) 
.IP "\(bu" 1
I2C_IT_BERR: Bus error flag 
.IP "\(bu" 1
I2C_IT_TXE: Data register empty flag (Transmitter) 
.IP "\(bu" 1
I2C_IT_RXNE: Data register not empty (Receiver) flag 
.IP "\(bu" 1
I2C_IT_STOPF: Stop detection flag (Slave mode) 
.IP "\(bu" 1
I2C_IT_ADD10: 10-bit header sent flag (Master mode) 
.IP "\(bu" 1
I2C_IT_BTF: Byte transfer finished flag 
.IP "\(bu" 1
I2C_IT_ADDR: Address sent flag (Master mode) 'ADSL' Address matched flag (Slave mode)'ENDAD' 
.IP "\(bu" 1
I2C_IT_SB: Start bit flag (Master mode) 
.PP
.RE
.PP
\fBReturn values\fP
.RS 4
\fIThe\fP new state of I2C_IT (SET or RESET)\&. 
.RE
.PP

.SS "uint32_t I2C_GetLastEvent (I2C_TypeDef * I2Cx)"

.PP
Returns the last I2Cx Event\&. 
.PP
\fBParameters\fP
.RS 4
\fII2Cx\fP where x can be 1, 2 or 3 to select the I2C peripheral\&.
.RE
.PP
\fBNote\fP
.RS 4
For detailed description of Events, please refer to section I2C_Events in \fBstm32f4xx_i2c\&.h\fP file\&.
.RE
.PP
\fBReturn values\fP
.RS 4
\fIThe\fP last event 
.RE
.PP

.SS "uint8_t I2C_GetPEC (I2C_TypeDef * I2Cx)"

.PP
Returns the PEC value for the specified I2C\&. 
.PP
\fBParameters\fP
.RS 4
\fII2Cx\fP where x can be 1, 2 or 3 to select the I2C peripheral\&. 
.RE
.PP
\fBReturn values\fP
.RS 4
\fIThe\fP PEC value\&. 
.RE
.PP

.SS "void I2C_Init (I2C_TypeDef * I2Cx, \fBI2C_InitTypeDef\fP * I2C_InitStruct)"

.PP
Initializes the I2Cx peripheral according to the specified parameters in the I2C_InitStruct\&. 
.PP
\fBNote\fP
.RS 4
To use the I2C at 400 KHz (in fast mode), the PCLK1 frequency (I2C peripheral input clock) must be a multiple of 10 MHz\&. 
.br
.RE
.PP
\fBParameters\fP
.RS 4
\fII2Cx\fP where x can be 1, 2 or 3 to select the I2C peripheral\&. 
.br
\fII2C_InitStruct\fP pointer to a \fBI2C_InitTypeDef\fP structure that contains the configuration information for the specified I2C peripheral\&. 
.RE
.PP
\fBReturn values\fP
.RS 4
\fINone\fP 
.RE
.PP

.SS "void I2C_ITConfig (I2C_TypeDef * I2Cx, uint16_t I2C_IT, FunctionalState NewState)"

.PP
Enables or disables the specified I2C interrupts\&. 
.PP
\fBParameters\fP
.RS 4
\fII2Cx\fP where x can be 1, 2 or 3 to select the I2C peripheral\&. 
.br
\fII2C_IT\fP specifies the I2C interrupts sources to be enabled or disabled\&. This parameter can be any combination of the following values: 
.PD 0
.IP "\(bu" 1
I2C_IT_BUF: Buffer interrupt mask 
.IP "\(bu" 1
I2C_IT_EVT: Event interrupt mask 
.IP "\(bu" 1
I2C_IT_ERR: Error interrupt mask 
.PP
.br
\fINewState\fP new state of the specified I2C interrupts\&. This parameter can be: ENABLE or DISABLE\&. 
.RE
.PP
\fBReturn values\fP
.RS 4
\fINone\fP 
.RE
.PP

.SS "void I2C_NACKPositionConfig (I2C_TypeDef * I2Cx, uint16_t I2C_NACKPosition)"

.PP
Selects the specified I2C NACK position in master receiver mode\&. 
.PP
\fBNote\fP
.RS 4
This function is useful in I2C Master Receiver mode when the number of data to be received is equal to 2\&. In this case, this function should be called (with parameter I2C_NACKPosition_Next) before data reception starts,as described in the 2-byte reception procedure recommended in Reference Manual in Section: Master receiver\&. 
.br
 
.RE
.PP
\fBParameters\fP
.RS 4
\fII2Cx\fP where x can be 1, 2 or 3 to select the I2C peripheral\&. 
.br
\fII2C_NACKPosition\fP specifies the NACK position\&. This parameter can be one of the following values: 
.PD 0
.IP "\(bu" 1
I2C_NACKPosition_Next: indicates that the next byte will be the last received byte\&. 
.br
 
.IP "\(bu" 1
I2C_NACKPosition_Current: indicates that current byte is the last received byte\&.
.PP
.RE
.PP
\fBNote\fP
.RS 4
This function configures the same bit (POS) as \fBI2C_PECPositionConfig()\fP but is intended to be used in I2C mode while \fBI2C_PECPositionConfig()\fP is intended to used in SMBUS mode\&.
.RE
.PP
\fBReturn values\fP
.RS 4
\fINone\fP 
.RE
.PP

.SS "void I2C_OwnAddress2Config (I2C_TypeDef * I2Cx, uint8_t Address)"

.PP
Configures the specified I2C own address2\&. 
.PP
\fBParameters\fP
.RS 4
\fII2Cx\fP where x can be 1, 2 or 3 to select the I2C peripheral\&. 
.br
\fIAddress\fP specifies the 7bit I2C own address2\&. 
.RE
.PP
\fBReturn values\fP
.RS 4
\fINone\&.\fP 
.RE
.PP

.SS "void I2C_PECPositionConfig (I2C_TypeDef * I2Cx, uint16_t I2C_PECPosition)"

.PP
Selects the specified I2C PEC position\&. 
.PP
\fBParameters\fP
.RS 4
\fII2Cx\fP where x can be 1, 2 or 3 to select the I2C peripheral\&. 
.br
\fII2C_PECPosition\fP specifies the PEC position\&. This parameter can be one of the following values: 
.PD 0
.IP "\(bu" 1
I2C_PECPosition_Next: indicates that the next byte is PEC 
.IP "\(bu" 1
I2C_PECPosition_Current: indicates that current byte is PEC
.PP
.RE
.PP
\fBNote\fP
.RS 4
This function configures the same bit (POS) as \fBI2C_NACKPositionConfig()\fP but is intended to be used in SMBUS mode while \fBI2C_NACKPositionConfig()\fP is intended to used in I2C mode\&.
.RE
.PP
\fBReturn values\fP
.RS 4
\fINone\fP 
.RE
.PP

.SS "uint16_t I2C_ReadRegister (I2C_TypeDef * I2Cx, uint8_t I2C_Register)"

.PP
Reads the specified I2C register and returns its value\&. 
.PP
\fBParameters\fP
.RS 4
\fII2C_Register\fP specifies the register to read\&. This parameter can be one of the following values: 
.PD 0
.IP "\(bu" 1
I2C_Register_CR1: CR1 register\&. 
.IP "\(bu" 1
I2C_Register_CR2: CR2 register\&. 
.IP "\(bu" 1
I2C_Register_OAR1: OAR1 register\&. 
.IP "\(bu" 1
I2C_Register_OAR2: OAR2 register\&. 
.IP "\(bu" 1
I2C_Register_DR: DR register\&. 
.IP "\(bu" 1
I2C_Register_SR1: SR1 register\&. 
.IP "\(bu" 1
I2C_Register_SR2: SR2 register\&. 
.IP "\(bu" 1
I2C_Register_CCR: CCR register\&. 
.IP "\(bu" 1
I2C_Register_TRISE: TRISE register\&. 
.PP
.RE
.PP
\fBReturn values\fP
.RS 4
\fIThe\fP value of the read register\&. 
.RE
.PP

.SS "uint8_t I2C_ReceiveData (I2C_TypeDef * I2Cx)"

.PP
Returns the most recent received data by the I2Cx peripheral\&. 
.PP
\fBParameters\fP
.RS 4
\fII2Cx\fP where x can be 1, 2 or 3 to select the I2C peripheral\&. 
.RE
.PP
\fBReturn values\fP
.RS 4
\fIThe\fP value of the received data\&. 
.RE
.PP

.SS "void I2C_Send7bitAddress (I2C_TypeDef * I2Cx, uint8_t Address, uint8_t I2C_Direction)"

.PP
Transmits the address byte to select the slave device\&. 
.PP
\fBParameters\fP
.RS 4
\fII2Cx\fP where x can be 1, 2 or 3 to select the I2C peripheral\&. 
.br
\fIAddress\fP specifies the slave address which will be transmitted 
.br
\fII2C_Direction\fP specifies whether the I2C device will be a Transmitter or a Receiver\&. This parameter can be one of the following values 
.PD 0
.IP "\(bu" 1
I2C_Direction_Transmitter: Transmitter mode 
.IP "\(bu" 1
I2C_Direction_Receiver: Receiver mode 
.PP
.RE
.PP
\fBReturn values\fP
.RS 4
\fINone\&.\fP 
.RE
.PP

.SS "void I2C_SendData (I2C_TypeDef * I2Cx, uint8_t Data)"

.PP
Sends a data byte through the I2Cx peripheral\&. 
.PP
\fBParameters\fP
.RS 4
\fII2Cx\fP where x can be 1, 2 or 3 to select the I2C peripheral\&. 
.br
\fIData\fP Byte to be transmitted\&.\&. 
.RE
.PP
\fBReturn values\fP
.RS 4
\fINone\fP 
.RE
.PP

.SS "void I2C_SMBusAlertConfig (I2C_TypeDef * I2Cx, uint16_t I2C_SMBusAlert)"

.PP
Drives the SMBusAlert pin high or low for the specified I2C\&. 
.PP
\fBParameters\fP
.RS 4
\fII2Cx\fP where x can be 1, 2 or 3 to select the I2C peripheral\&. 
.br
\fII2C_SMBusAlert\fP specifies SMBAlert pin level\&. This parameter can be one of the following values: 
.PD 0
.IP "\(bu" 1
I2C_SMBusAlert_Low: SMBAlert pin driven low 
.IP "\(bu" 1
I2C_SMBusAlert_High: SMBAlert pin driven high 
.PP
.RE
.PP
\fBReturn values\fP
.RS 4
\fINone\fP 
.RE
.PP

.SS "void I2C_SoftwareResetCmd (I2C_TypeDef * I2Cx, FunctionalState NewState)"

.PP
Enables or disables the specified I2C software reset\&. 
.PP
\fBNote\fP
.RS 4
When software reset is enabled, the I2C IOs are released (this can be useful to recover from bus errors)\&. 
.br
 
.RE
.PP
\fBParameters\fP
.RS 4
\fII2Cx\fP where x can be 1, 2 or 3 to select the I2C peripheral\&. 
.br
\fINewState\fP new state of the I2C software reset\&. This parameter can be: ENABLE or DISABLE\&. 
.RE
.PP
\fBReturn values\fP
.RS 4
\fINone\fP 
.RE
.PP

.SS "void I2C_StretchClockCmd (I2C_TypeDef * I2Cx, FunctionalState NewState)"

.PP
Enables or disables the specified I2C Clock stretching\&. 
.PP
\fBParameters\fP
.RS 4
\fII2Cx\fP where x can be 1, 2 or 3 to select the I2C peripheral\&. 
.br
\fINewState\fP new state of the I2Cx Clock stretching\&. This parameter can be: ENABLE or DISABLE\&. 
.RE
.PP
\fBReturn values\fP
.RS 4
\fINone\fP 
.RE
.PP

.SS "void I2C_StructInit (\fBI2C_InitTypeDef\fP * I2C_InitStruct)"

.PP
Fills each I2C_InitStruct member with its default value\&. 
.PP
\fBParameters\fP
.RS 4
\fII2C_InitStruct\fP pointer to an \fBI2C_InitTypeDef\fP structure which will be initialized\&. 
.RE
.PP
\fBReturn values\fP
.RS 4
\fINone\fP 
.RE
.PP

.SS "void I2C_TransmitPEC (I2C_TypeDef * I2Cx, FunctionalState NewState)"

.PP
Enables or disables the specified I2C PEC transfer\&. 
.PP
\fBParameters\fP
.RS 4
\fII2Cx\fP where x can be 1, 2 or 3 to select the I2C peripheral\&. 
.br
\fINewState\fP new state of the I2C PEC transmission\&. This parameter can be: ENABLE or DISABLE\&. 
.RE
.PP
\fBReturn values\fP
.RS 4
\fINone\fP 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for Square Root Approximation from the source code\&.
