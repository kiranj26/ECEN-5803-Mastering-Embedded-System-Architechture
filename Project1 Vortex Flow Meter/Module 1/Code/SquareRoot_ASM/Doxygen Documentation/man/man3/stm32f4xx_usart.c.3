.TH "drivers/stm32f4xx_usart.c" 3 "Version 0.1.-" "Square Root Approximation" \" -*- nroff -*-
.ad l
.nh
.SH NAME
drivers/stm32f4xx_usart.c \- This file provides firmware functions to manage the following functionalities of the Universal synchronous asynchronous receiver transmitter (USART): 
.br
  

.SH SYNOPSIS
.br
.PP
\fC#include 'stm32f4xx_rcc\&.h'\fP
.br
\fC#include 'stm32f4xx_usart\&.h'\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBCR1_CLEAR_MASK\fP"
.br
.ti -1c
.RI "#define \fBCR2_CLOCK_CLEAR_MASK\fP"
.br
.ti -1c
.RI "#define \fBCR3_CLEAR_MASK\fP   ((uint16_t)(USART_CR3_RTSE | USART_CR3_CTSE))"
.br
.ti -1c
.RI "#define \fBIT_MASK\fP   ((uint16_t)0x001F)"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBUSART_DeInit\fP (USART_TypeDef *USARTx)"
.br
.RI "Deinitializes the USARTx peripheral registers to their default reset values\&. "
.ti -1c
.RI "void \fBUSART_Init\fP (USART_TypeDef *USARTx, \fBUSART_InitTypeDef\fP *USART_InitStruct)"
.br
.RI "Initializes the USARTx peripheral according to the specified parameters in the USART_InitStruct \&. "
.ti -1c
.RI "void \fBUSART_StructInit\fP (\fBUSART_InitTypeDef\fP *USART_InitStruct)"
.br
.RI "Fills each USART_InitStruct member with its default value\&. "
.ti -1c
.RI "void \fBUSART_ClockInit\fP (USART_TypeDef *USARTx, \fBUSART_ClockInitTypeDef\fP *USART_ClockInitStruct)"
.br
.RI "Initializes the USARTx peripheral Clock according to the specified parameters in the USART_ClockInitStruct \&. "
.ti -1c
.RI "void \fBUSART_ClockStructInit\fP (\fBUSART_ClockInitTypeDef\fP *USART_ClockInitStruct)"
.br
.RI "Fills each USART_ClockInitStruct member with its default value\&. "
.ti -1c
.RI "void \fBUSART_Cmd\fP (USART_TypeDef *USARTx, FunctionalState NewState)"
.br
.RI "Enables or disables the specified USART peripheral\&. "
.ti -1c
.RI "void \fBUSART_SetPrescaler\fP (USART_TypeDef *USARTx, uint8_t USART_Prescaler)"
.br
.RI "Sets the system clock prescaler\&. "
.ti -1c
.RI "void \fBUSART_OverSampling8Cmd\fP (USART_TypeDef *USARTx, FunctionalState NewState)"
.br
.RI "Enables or disables the USART's 8x oversampling mode\&. "
.ti -1c
.RI "void \fBUSART_OneBitMethodCmd\fP (USART_TypeDef *USARTx, FunctionalState NewState)"
.br
.RI "Enables or disables the USART's one bit sampling method\&. "
.ti -1c
.RI "void \fBUSART_SendData\fP (USART_TypeDef *USARTx, uint16_t Data)"
.br
.RI "Transmits single data through the USARTx peripheral\&. "
.ti -1c
.RI "uint16_t \fBUSART_ReceiveData\fP (USART_TypeDef *USARTx)"
.br
.RI "Returns the most recent received data by the USARTx peripheral\&. "
.ti -1c
.RI "void \fBUSART_SetAddress\fP (USART_TypeDef *USARTx, uint8_t USART_Address)"
.br
.RI "Sets the address of the USART node\&. "
.ti -1c
.RI "void \fBUSART_ReceiverWakeUpCmd\fP (USART_TypeDef *USARTx, FunctionalState NewState)"
.br
.RI "Determines if the USART is in mute mode or not\&. "
.ti -1c
.RI "void \fBUSART_WakeUpConfig\fP (USART_TypeDef *USARTx, uint16_t USART_WakeUp)"
.br
.RI "Selects the USART WakeUp method\&. "
.ti -1c
.RI "void \fBUSART_LINBreakDetectLengthConfig\fP (USART_TypeDef *USARTx, uint16_t USART_LINBreakDetectLength)"
.br
.RI "Sets the USART LIN Break detection length\&. "
.ti -1c
.RI "void \fBUSART_LINCmd\fP (USART_TypeDef *USARTx, FunctionalState NewState)"
.br
.RI "Enables or disables the USART's LIN mode\&. "
.ti -1c
.RI "void \fBUSART_SendBreak\fP (USART_TypeDef *USARTx)"
.br
.RI "Transmits break characters\&. "
.ti -1c
.RI "void \fBUSART_HalfDuplexCmd\fP (USART_TypeDef *USARTx, FunctionalState NewState)"
.br
.RI "Enables or disables the USART's Half Duplex communication\&. "
.ti -1c
.RI "void \fBUSART_SetGuardTime\fP (USART_TypeDef *USARTx, uint8_t USART_GuardTime)"
.br
.RI "Sets the specified USART guard time\&. "
.ti -1c
.RI "void \fBUSART_SmartCardCmd\fP (USART_TypeDef *USARTx, FunctionalState NewState)"
.br
.RI "Enables or disables the USART's Smart Card mode\&. "
.ti -1c
.RI "void \fBUSART_SmartCardNACKCmd\fP (USART_TypeDef *USARTx, FunctionalState NewState)"
.br
.RI "Enables or disables NACK transmission\&. "
.ti -1c
.RI "void \fBUSART_IrDAConfig\fP (USART_TypeDef *USARTx, uint16_t USART_IrDAMode)"
.br
.RI "Configures the USART's IrDA interface\&. "
.ti -1c
.RI "void \fBUSART_IrDACmd\fP (USART_TypeDef *USARTx, FunctionalState NewState)"
.br
.RI "Enables or disables the USART's IrDA interface\&. "
.ti -1c
.RI "void \fBUSART_DMACmd\fP (USART_TypeDef *USARTx, uint16_t USART_DMAReq, FunctionalState NewState)"
.br
.RI "Enables or disables the USART's DMA interface\&. "
.ti -1c
.RI "void \fBUSART_ITConfig\fP (USART_TypeDef *USARTx, uint16_t USART_IT, FunctionalState NewState)"
.br
.RI "Enables or disables the specified USART interrupts\&. "
.ti -1c
.RI "FlagStatus \fBUSART_GetFlagStatus\fP (USART_TypeDef *USARTx, uint16_t USART_FLAG)"
.br
.RI "Checks whether the specified USART flag is set or not\&. "
.ti -1c
.RI "void \fBUSART_ClearFlag\fP (USART_TypeDef *USARTx, uint16_t USART_FLAG)"
.br
.RI "Clears the USARTx's pending flags\&. "
.ti -1c
.RI "ITStatus \fBUSART_GetITStatus\fP (USART_TypeDef *USARTx, uint16_t USART_IT)"
.br
.RI "Checks whether the specified USART interrupt has occurred or not\&. "
.ti -1c
.RI "void \fBUSART_ClearITPendingBit\fP (USART_TypeDef *USARTx, uint16_t USART_IT)"
.br
.RI "Clears the USARTx's interrupt pending bits\&. "
.in -1c
.SH "Detailed Description"
.PP 
This file provides firmware functions to manage the following functionalities of the Universal synchronous asynchronous receiver transmitter (USART): 
.br
 


.PP
\fBAuthor\fP
.RS 4
MCD Application Team 
.RE
.PP
\fBVersion\fP
.RS 4
V1\&.0\&.0 
.RE
.PP
\fBDate\fP
.RS 4
30-September-2011
.IP "\(bu" 2
Initialization and Configuration
.IP "\(bu" 2
Data transfers
.IP "\(bu" 2
Multi-Processor Communication
.IP "\(bu" 2
LIN mode
.IP "\(bu" 2
Half-duplex mode
.IP "\(bu" 2
Smartcard mode
.IP "\(bu" 2
IrDA mode
.IP "\(bu" 2
DMA transfers management
.IP "\(bu" 2
Interrupts and flags management
.PP
.RE
.PP
.PP
.nf
*      
*          ===================================================================
*                                 How to use this driver
*          ===================================================================
*          1\&. Enable peripheral clock using the follwoing functions
*             RCC_APB2PeriphClockCmd(RCC_APB2Periph_USARTx, ENABLE) for USART1 and USART6 
*             RCC_APB1PeriphClockCmd(RCC_APB1Periph_USARTx, ENABLE) for USART2, USART3, UART4 or UART5\&.
*
*          2\&.  According to the USART mode, enable the GPIO clocks using 
*              RCC_AHB1PeriphClockCmd() function\&. (The I/O can be TX, RX, CTS, 
*              or/and SCLK)\&. 
*
*          3\&. Peripheral's alternate function: 
*                 - Connect the pin to the desired peripherals' Alternate 
*                   Function (AF) using GPIO_PinAFConfig() function
*                 - Configure the desired pin in alternate function by:
*                   GPIO_InitStruct->GPIO_Mode = GPIO_Mode_AF
*                 - Select the type, pull-up/pull-down and output speed via 
*                   GPIO_PuPd, GPIO_OType and GPIO_Speed members
*                 - Call GPIO_Init() function
*        
*          4\&. Program the Baud Rate, Word Length , Stop Bit, Parity, Hardware 
*             flow control and Mode(Receiver/Transmitter) using the USART_Init()
*             function\&.
*
*          5\&. For synchronous mode, enable the clock and program the polarity,
*             phase and last bit using the USART_ClockInit() function\&.
*
*          5\&. Enable the NVIC and the corresponding interrupt using the function 
*             USART_ITConfig() if you need to use interrupt mode\&. 
*
*          6\&. When using the DMA mode 
*                   - Configure the DMA using DMA_Init() function
*                   - Active the needed channel Request using USART_DMACmd() function
* 
*          7\&. Enable the USART using the USART_Cmd() function\&.
* 
*          8\&. Enable the DMA using the DMA_Cmd() function, when using DMA mode\&. 
*
*          Refer to Multi-Processor, LIN, half-duplex, Smartcard, IrDA sub-sections
*          for more details
*          
*          In order to reach higher communication baudrates, it is possible to
*          enable the oversampling by 8 mode using the function USART_OverSampling8Cmd()\&.
*          This function should be called after enabling the USART clock (RCC_APBxPeriphClockCmd())
*          and before calling the function USART_Init()\&.
*          
*  .fi
.PP
.PP
\fBAttention\fP
.RS 4
.RE
.PP
THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME\&. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS\&.
.PP
.SS "(C) COPYRIGHT 2011 STMicroelectronics"

.SH "Author"
.PP 
Generated automatically by Doxygen for Square Root Approximation from the source code\&.
