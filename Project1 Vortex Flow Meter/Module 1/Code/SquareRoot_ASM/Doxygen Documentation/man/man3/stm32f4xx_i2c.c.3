.TH "drivers/stm32f4xx_i2c.c" 3 "Version 0.1.-" "Square Root Approximation" \" -*- nroff -*-
.ad l
.nh
.SH NAME
drivers/stm32f4xx_i2c.c \- This file provides firmware functions to manage the following functionalities of the Inter-integrated circuit (I2C)  

.SH SYNOPSIS
.br
.PP
\fC#include 'stm32f4xx_i2c\&.h'\fP
.br
\fC#include 'stm32f4xx_rcc\&.h'\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBCR1_CLEAR_MASK\fP   ((uint16_t)0xFBF5)      /*<! I2C registers Masks */"
.br
.ti -1c
.RI "#define \fBFLAG_MASK\fP   ((uint32_t)0x00FFFFFF)  /*<! I2C FLAG mask */"
.br
.ti -1c
.RI "#define \fBITEN_MASK\fP   ((uint32_t)0x07000000)  /*<! I2C Interrupt Enable mask */"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBI2C_DeInit\fP (I2C_TypeDef *I2Cx)"
.br
.RI "Deinitialize the I2Cx peripheral registers to their default reset values\&. "
.ti -1c
.RI "void \fBI2C_Init\fP (I2C_TypeDef *I2Cx, \fBI2C_InitTypeDef\fP *I2C_InitStruct)"
.br
.RI "Initializes the I2Cx peripheral according to the specified parameters in the I2C_InitStruct\&. "
.ti -1c
.RI "void \fBI2C_StructInit\fP (\fBI2C_InitTypeDef\fP *I2C_InitStruct)"
.br
.RI "Fills each I2C_InitStruct member with its default value\&. "
.ti -1c
.RI "void \fBI2C_Cmd\fP (I2C_TypeDef *I2Cx, FunctionalState NewState)"
.br
.RI "Enables or disables the specified I2C peripheral\&. "
.ti -1c
.RI "void \fBI2C_GenerateSTART\fP (I2C_TypeDef *I2Cx, FunctionalState NewState)"
.br
.RI "Generates I2Cx communication START condition\&. "
.ti -1c
.RI "void \fBI2C_GenerateSTOP\fP (I2C_TypeDef *I2Cx, FunctionalState NewState)"
.br
.RI "Generates I2Cx communication STOP condition\&. "
.ti -1c
.RI "void \fBI2C_Send7bitAddress\fP (I2C_TypeDef *I2Cx, uint8_t Address, uint8_t I2C_Direction)"
.br
.RI "Transmits the address byte to select the slave device\&. "
.ti -1c
.RI "void \fBI2C_AcknowledgeConfig\fP (I2C_TypeDef *I2Cx, FunctionalState NewState)"
.br
.RI "Enables or disables the specified I2C acknowledge feature\&. "
.ti -1c
.RI "void \fBI2C_OwnAddress2Config\fP (I2C_TypeDef *I2Cx, uint8_t Address)"
.br
.RI "Configures the specified I2C own address2\&. "
.ti -1c
.RI "void \fBI2C_DualAddressCmd\fP (I2C_TypeDef *I2Cx, FunctionalState NewState)"
.br
.RI "Enables or disables the specified I2C dual addressing mode\&. "
.ti -1c
.RI "void \fBI2C_GeneralCallCmd\fP (I2C_TypeDef *I2Cx, FunctionalState NewState)"
.br
.RI "Enables or disables the specified I2C general call feature\&. "
.ti -1c
.RI "void \fBI2C_SoftwareResetCmd\fP (I2C_TypeDef *I2Cx, FunctionalState NewState)"
.br
.RI "Enables or disables the specified I2C software reset\&. "
.ti -1c
.RI "void \fBI2C_StretchClockCmd\fP (I2C_TypeDef *I2Cx, FunctionalState NewState)"
.br
.RI "Enables or disables the specified I2C Clock stretching\&. "
.ti -1c
.RI "void \fBI2C_FastModeDutyCycleConfig\fP (I2C_TypeDef *I2Cx, uint16_t I2C_DutyCycle)"
.br
.RI "Selects the specified I2C fast mode duty cycle\&. "
.ti -1c
.RI "void \fBI2C_NACKPositionConfig\fP (I2C_TypeDef *I2Cx, uint16_t I2C_NACKPosition)"
.br
.RI "Selects the specified I2C NACK position in master receiver mode\&. "
.ti -1c
.RI "void \fBI2C_SMBusAlertConfig\fP (I2C_TypeDef *I2Cx, uint16_t I2C_SMBusAlert)"
.br
.RI "Drives the SMBusAlert pin high or low for the specified I2C\&. "
.ti -1c
.RI "void \fBI2C_ARPCmd\fP (I2C_TypeDef *I2Cx, FunctionalState NewState)"
.br
.RI "Enables or disables the specified I2C ARP\&. "
.ti -1c
.RI "void \fBI2C_SendData\fP (I2C_TypeDef *I2Cx, uint8_t Data)"
.br
.RI "Sends a data byte through the I2Cx peripheral\&. "
.ti -1c
.RI "uint8_t \fBI2C_ReceiveData\fP (I2C_TypeDef *I2Cx)"
.br
.RI "Returns the most recent received data by the I2Cx peripheral\&. "
.ti -1c
.RI "void \fBI2C_TransmitPEC\fP (I2C_TypeDef *I2Cx, FunctionalState NewState)"
.br
.RI "Enables or disables the specified I2C PEC transfer\&. "
.ti -1c
.RI "void \fBI2C_PECPositionConfig\fP (I2C_TypeDef *I2Cx, uint16_t I2C_PECPosition)"
.br
.RI "Selects the specified I2C PEC position\&. "
.ti -1c
.RI "void \fBI2C_CalculatePEC\fP (I2C_TypeDef *I2Cx, FunctionalState NewState)"
.br
.RI "Enables or disables the PEC value calculation of the transferred bytes\&. "
.ti -1c
.RI "uint8_t \fBI2C_GetPEC\fP (I2C_TypeDef *I2Cx)"
.br
.RI "Returns the PEC value for the specified I2C\&. "
.ti -1c
.RI "void \fBI2C_DMACmd\fP (I2C_TypeDef *I2Cx, FunctionalState NewState)"
.br
.RI "Enables or disables the specified I2C DMA requests\&. "
.ti -1c
.RI "void \fBI2C_DMALastTransferCmd\fP (I2C_TypeDef *I2Cx, FunctionalState NewState)"
.br
.RI "Specifies that the next DMA transfer is the last one\&. "
.ti -1c
.RI "uint16_t \fBI2C_ReadRegister\fP (I2C_TypeDef *I2Cx, uint8_t I2C_Register)"
.br
.RI "Reads the specified I2C register and returns its value\&. "
.ti -1c
.RI "void \fBI2C_ITConfig\fP (I2C_TypeDef *I2Cx, uint16_t I2C_IT, FunctionalState NewState)"
.br
.RI "Enables or disables the specified I2C interrupts\&. "
.ti -1c
.RI "ErrorStatus \fBI2C_CheckEvent\fP (I2C_TypeDef *I2Cx, uint32_t I2C_EVENT)"
.br
.RI "Checks whether the last I2Cx Event is equal to the one passed as parameter\&. "
.ti -1c
.RI "uint32_t \fBI2C_GetLastEvent\fP (I2C_TypeDef *I2Cx)"
.br
.RI "Returns the last I2Cx Event\&. "
.ti -1c
.RI "FlagStatus \fBI2C_GetFlagStatus\fP (I2C_TypeDef *I2Cx, uint32_t I2C_FLAG)"
.br
.RI "Checks whether the specified I2C flag is set or not\&. "
.ti -1c
.RI "void \fBI2C_ClearFlag\fP (I2C_TypeDef *I2Cx, uint32_t I2C_FLAG)"
.br
.RI "Clears the I2Cx's pending flags\&. "
.ti -1c
.RI "ITStatus \fBI2C_GetITStatus\fP (I2C_TypeDef *I2Cx, uint32_t I2C_IT)"
.br
.RI "Checks whether the specified I2C interrupt has occurred or not\&. "
.ti -1c
.RI "void \fBI2C_ClearITPendingBit\fP (I2C_TypeDef *I2Cx, uint32_t I2C_IT)"
.br
.RI "Clears the I2Cx's interrupt pending bits\&. "
.in -1c
.SH "Detailed Description"
.PP 
This file provides firmware functions to manage the following functionalities of the Inter-integrated circuit (I2C) 


.PP
\fBAuthor\fP
.RS 4
MCD Application Team 
.RE
.PP
\fBVersion\fP
.RS 4
V1\&.0\&.0 
.RE
.PP
\fBDate\fP
.RS 4
30-September-2011
.IP "\(bu" 2
Initialization and Configuration
.IP "\(bu" 2
Data transfers
.IP "\(bu" 2
PEC management
.IP "\(bu" 2
DMA transfers management
.IP "\(bu" 2
Interrupts, events and flags management
.PP
.RE
.PP
.PP
.nf
*    
*          ===================================================================
*                                 How to use this driver
*          ===================================================================
*          1\&. Enable peripheral clock using RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2Cx, ENABLE)
*             function for I2C1, I2C2 or I2C3\&.
*
*          2\&. Enable SDA, SCL  and SMBA (when used) GPIO clocks using 
*             RCC_AHBPeriphClockCmd() function\&. 
*
*          3\&. Peripherals alternate function: 
*                 - Connect the pin to the desired peripherals' Alternate 
*                   Function (AF) using GPIO_PinAFConfig() function
*                 - Configure the desired pin in alternate function by:
*                   GPIO_InitStruct->GPIO_Mode = GPIO_Mode_AF
*                 - Select the type, pull-up/pull-down and output speed via 
*                   GPIO_PuPd, GPIO_OType and GPIO_Speed members
*                 - Call GPIO_Init() function
*                 Recommended configuration is Push-Pull, Pull-up, Open-Drain\&.
*                 Add an external pull up if necessary (typically 4\&.7 KOhm)\&.      
*        
*          4\&. Program the Mode, duty cycle , Own address, Ack, Speed and Acknowledged
*             Address using the I2C_Init() function\&.
*
*          5\&. Optionally you can enable/configure the following parameters without
*             re-initialization (i\&.e there is no need to call again I2C_Init() function):
*              - Enable the acknowledge feature using I2C_AcknowledgeConfig() function
*              - Enable the dual addressing mode using I2C_DualAddressCmd() function
*              - Enable the general call using the I2C_GeneralCallCmd() function
*              - Enable the clock stretching using I2C_StretchClockCmd() function
*              - Enable the fast mode duty cycle using the I2C_FastModeDutyCycleConfig()
*                function\&.
*              - Configure the NACK position for Master Receiver mode in case of 
*                2 bytes reception using the function I2C_NACKPositionConfig()\&.  
*              - Enable the PEC Calculation using I2C_CalculatePEC() function
*              - For SMBus Mode: 
*                   - Enable the Address Resolution Protocol (ARP) using I2C_ARPCmd() function
*                   - Configure the SMBusAlert pin using I2C_SMBusAlertConfig() function
*
*          6\&. Enable the NVIC and the corresponding interrupt using the function 
*             I2C_ITConfig() if you need to use interrupt mode\&. 
*
*          7\&. When using the DMA mode 
*                   - Configure the DMA using DMA_Init() function
*                   - Active the needed channel Request using I2C_DMACmd() or
*                     I2C_DMALastTransferCmd() function\&.
*              @note When using DMA mode, I2C interrupts may be used at the same time to
*                    control the communication flow (Start/Stop/Ack\&.\&.\&. events and errors)\&.
* 
*          8\&. Enable the I2C using the I2C_Cmd() function\&.
* 
*          9\&. Enable the DMA using the DMA_Cmd() function when using DMA mode in the 
*             transfers\&. 
*
*  .fi
.PP
.PP
\fBAttention\fP
.RS 4
.RE
.PP
THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME\&. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS\&.
.PP
.SS "(C) COPYRIGHT 2011 STMicroelectronics"

.SH "Author"
.PP 
Generated automatically by Doxygen for Square Root Approximation from the source code\&.
